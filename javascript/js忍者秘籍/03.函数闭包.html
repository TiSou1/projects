<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="box1" style="background-color: aquamarine;width: 100px;height: 100px;position: relative;;"></div>
    <script>
        /*  
        ■ 使用闭包简化代码
        ■ 使用执行上下文跟踪JavaScript程序的执行
        ■ 使用词法环境（Lexical Environment）跟踪变量的作用域
        ■ 理解变量的类型
        ■ 探讨闭包的工作原理 
        
        使用闭包，不仅可以通过减少代码数量和复杂度来添加高级特性，还能实现不太可能完成的功能。
        换句话说，如果没有闭包，事情将变得非常复杂。
        例如，如果没有闭包，事件处理和动画等包含回调函数的任务，它们的实现将变得复杂得多。
        除此之外，如果没有闭包，将完全不可能实现私有变量*/

        /* 理解闭包
            闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。 */
        //例:一个简单的闭包
        let outValue = 'ninja';
        function outerFunction(){
            console.log(outValue === 'ninja')
        }
        outerFunction();
        /*
        该函数可以“看见”并访问变量outerValue。我们可能已经写过上百次这样的代码，但是却没有意识到其实我们正在创建一个闭包！ 
        因为外部变量outerValue和外部函数outerFunction都是在全局作用域中声明的，该作用域（实际上就是一个闭包）从未消失（只要应用处于运行状态）
        该函数可以访问到外部变量，因为它仍然在作用域内并且是可见的。 */
        
        //例:
        let out = 'sam';
        let later;
        function outF(){
            let inner = 'ninja';
            function innerFunction(){
                console.log(out === 'sam');
                console.log(inner === 'ninja');
            }
            later = innerFunction;//获取内部函数的引用
        }
        outF();
        later()
        /* 
        这怎么可能呢？是什么魔法使得在内部函数的作用域消失之后再执行内部函数时，其内部变量仍然存在呢？
         - 当在外部函数中声明内部函数时,不仅定义了函数的声明,而且还创建了一个闭包.
            该闭包不仅包含了函数声明,还包含了在函数生命时该作用域中的所有变量.
            当最终执行内部函数时,尽管声明时的作用域已经消失,但是通过闭包,仍然你能够访问原始作用域
         - 只要内部函数一直存在，内部函数的闭包就一直保存着该函数的作用域中的变量
         - 这就是闭包.
         - 闭包创建了被定义时的作用域内的变量和函数的安全气泡，因此函数获得了执行时所需的内容。该气泡与函数本身一起包含了函数和变量。
         */


         /* 使用闭包 */
         //封装私有变量
         //原生JavaScript不支持私有变量。但是，通过使用闭包，我们可以实现很接近的、可接受的私有变量，
         //例:使用闭包模拟私有变量
        function Ninja(){
            //声明"私有变量"
            let feints = 0;
            //定义getFeints方法,让feints能够在外部被访问
            this.getFeints = function (){
                return feints;
            } //定义feint方法,让feints能够在外部被操作
            this.feint = function(){
                feints++;
            }
        }
        let ninja1 = new Ninja();//生成实例
        ninja1.feint();

        console.log(ninja1.feints);
        console.log(ninja1.getFeints());
        let ninja2 = new Ninja();
        console.log(ninja2.getFeints());
        /* 通过使用闭包，可以通过方法对ninja的状态进行维护，
        而不允许用户直接访问——这是因为闭包内部的变量可以通过闭包内的方法访问，
        构造器外部的代码则不能访问闭包内部的变量。 */

        /* 回调函数
            处理回调函数是另一种常见的使用闭包的情景。回调函数指的是需要在将来不确定的某一时刻异步调用的函数。 */
        //例: 在interval的回调函数中使用闭包
        function animateIt(elementId){
            let elem = document.getElementById(elementId);
            let tick = 0;
            let timer = setInterval(function(){
                if(tick<100){
                    elem.style.left = elem.style.top = tick +'px';
                    tick++;
                }
                else{
                    clearInterval(timer);//清除定时器
                    console.log(tick===100);
                    console.log(elem);
                    console.log(timer);

                }
            },10);
        }
        animateIt('box1');
        /* 
            当将elem,tick,tick移入到全局作用域时,也能正常使用,但是如果再为一个新的元素添加动画,
            就需要在设置3个变量.以上就是利用闭包的作用
        如果没有闭包，一次性同时做许多事情，例如事件绑定、动画甚至服务端请求等，都将会变得非常困难。如果你想知道关注闭包的理由，那么这就是理由！
        
        闭包内的函数不仅可以在创建的时刻访问这些变量，而且当闭包内部的函数执行时，
        还可以更新这些变量的值。闭包不是在创建的那一时刻的状态的快照，而是一个真实的状态封装，
        只要闭包存在，就可以对变量进行修改。

        ● 每个动画都在处理程序的闭包内获得私有变量。
        ● 该实例无法访问其他闭包内的变量。
        ● 这个实例也不能访问其他闭包内的变量。
         */


         //***********通过执行上下文来跟踪代码
        // JavaScript代码有两种类型：
        //一种是全局代码，在所有函数外部定义；
       // 一种是函数代码，位于函数内部。JavaScript引擎执行代码时，每一条语句都处于特定的执行上下文中。
       /* 
       既然具有两种类型的代码，那么就有两种执行上下文：
        全局执行上下文和函数执行上下文。
    二者最重要的差别是：
        全局执行上下文只有一个，当JavaScript程序开始执行时就已经创建了全局上下文；
        而函数执行上下文是在每次调用函数时，就会创建一个新的。

       执行上下文是内部的JavaScript概念，JavaScript引擎使用执行上下文来跟踪函数的执行。
        JavaScript基于单线程的执行模型：
            在某个特定的时刻只能执行特定的代码。一旦发生函数调用，当前的执行上下文必须停止执行，
            并创建新的函数执行上下文来执行函数。当函数执行完成后，将函数执行上下文销毁，
            并重新回到发生调用时的执行上下文中。所以需要跟踪执行上下文——正在执行的上下文以及
            正在等待的上下文。最简单的跟踪方法是使用执行上下文栈（或称为调用栈）。
        */

        //例:创建执行上下文
        function skulk(ninja){
            //调用另一个函数
            report(ninja+'skulking');
        }
        function report(value){
            console.log(value);
        }
        skulk('kuma');
        skulk('yoshui');
        /* 通过以上简单探讨执行上下文如何创建
            1.每个js程序只创建一个全局执行上下文,并从全局执行上下文开始执行(（在单页应用中每个页面只有一个全局执行上下文）)
                当执行全局代码时,全局上下文处于活跃状态
            2.首先在全局代码中定义两个函数：skulk和report，然后调用skulk("Kuma")。
                由于在同一个特定时刻只能执行特定代码，所以JavaScript引擎停止执行全局代码，
                开始执行带有Kuma参数的skulk函数。创建新的函数执行上下文，并置入执行上下文栈的顶部。 
            3.skulk函数进而调用report函数。又一次因为在同一个特定时刻只能执行特定代码，
                所以，暂停skulk执行上下文，创建新的Kuma作为参数的report函数的执行上下文，
                并置入执行上下文栈的顶部。
            4.report通过内置函数console.log（详见附录B）打印出消息后，report函数执行完成，
                代码又回到了skulk函数。report执行上下文从执行上下文栈顶部弹出，
                skulk函数执行上下文重新激活，skulk函数继续执行。
            5.skulk函数执行完成后也发生类似的事情：skulk函数执行上下文从栈顶端弹出，
                重新激活一直在等待的全局执行上下文并恢复执行。JavaScript的全局代码恢复执行。
            6.skulk函数第二次执行时，整个过程是类似的
                */


    /* 5.4 使用词法环境跟踪变量的作用域 
        词法环境（lexical environment）是JavaScript引擎内部用来跟踪标识符与特定变量之间的映射关系
        词法环境是JavaScript作用域的内部实现机制，人们通常称为作用域(scopes)。
        通常来说，词法环境与特定的JavaScript代码结构关联，既可以是一个函数、一段代码片段，
        也可以是try-catch语句。这些代码结构（函数、代码片段、try-catch）可以具有独立的标识符映射表。
        */
        let n1 = 'asdasd'
        console.log(n1);
        //当console.log(n1)时访问n1变量时,会进行词法环境的查询
    
        /* 5.4.1代码嵌套
            词法环境主要基于代码嵌套，通过代码嵌套可以实现代码结构包含另一代码结构。 */
        
        /* 5.4.2 代码嵌套与词法环境
            除了跟踪局部变量、函数声明、函数的参数和词法环境外，还有必要跟踪外部（父级）词法环境。
            因为我们需要访问外部代码结构中的变量，如果在当前环境中无法找到某一标识符，
            就会对外部环境进行查找。一旦查找到匹配的变量，或是在全局环境中仍然无法查找到对应的标识符而返回错误，就会停止查找。 */
        

        /* 5.5 理解JavaScript的变量类型
             */
             /* 5.5.1 变量可变性
                将const放在一组，var和let放在一组。通过const定义的变量都不可变，
                也就是说通过const声明的变量的值只能设置一次。通过var或let声明的变量的值可以变更任意次数。 */
            /* const
                const变量常用于两种目的：
                ● 不需要重新赋值的特殊变量（在本书的后续章节中，我们也会这样使用）。
                ● 指向一个固定的值，例如球队人数的最大值，可通过const变量MAX_RONIN_COUNT来表示，而不是仅仅通过数字234来表示。
                这使得代码更加易于理解和维护。虽然在代码里没有直接使用数字234，
                但是通过语义化的变量名MAX_RONIN_COUNT来表示，MAX_RONIN_COUNT的值只能指定一次。
                
                我们不能将一个全新的值赋值给const变量。但是，我们可以修改const变量已有的对象。

                关键字var用于定义函数作用域或全局作用域内的变量，而let允许定义块级作用域、函数作用域、全局作用域内的变量。
                 */

    //  5.6 研究闭包的工作原理
    /* 5.7 小结
    ● 通过闭包可以访问创建闭包时所处环境中的全部变量。闭包为函数创建时所处的作用域中的函数和变量，
    创建“安全气泡”。通过这种的方式，即使创建函数时所处的作用域已经消失，
    但是函数仍然能够获得执行时所需的全部内容。
    ● 我们可以使用闭包的这些高级功能：
        - 通过构造函数内的变量以及构造方法来模拟对象的私有属性。
        - 处理回调函数，简化代码。
    ● JavaScript引擎通过执行上下文栈（调用栈）跟踪函数的执行。每次调用函数时，
        都会创建新的函数执行上下文，并推入调用栈顶端。当函数执行完成后，
        对应的执行上下文将从调用栈中推出。
    ● JavaScript引擎通过词法环境跟踪标识符（俗称作用域）。
    ● 在JavaScript中，我们可以定义全局级别、函数级别甚至块级别的变量。
    ● 可以使用关键字var、let与const定义变量：
        - 关键字var定义距离最近的函数级变量或全局变量。
        - 关键字let与const定义距离最近级别的变量，包括块级变量。
        块级变量在ES6之前版本的JavaScript中是无法实现的。
        此外，通过关键字const允许定义只能赋值一次的变量。
     ● 闭包是JavaScript作用域规则的副作用。当函数创建时所在的作用域消失后，仍然能够调用函数。 */
    </script>
</body>
</html>